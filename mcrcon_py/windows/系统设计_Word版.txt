二、系统设计

本章主要阐述系统的整体架构、核心技术实现原理以及模块划分，为后续的编码实现提供清晰的蓝图。

1. 系统架构

本系统采用客户端/服务器（Client/Server, C/S）模型。我们开发的Python程序作为客户端，负责发起请求；Minecraft游戏服务器作为服务器端，负责响应请求。两者之间通过TCP/IP协议进行通信，交互的数据遵循MCRcon协议规范。

基本交互流程为：客户端认证 -> 客户端发送指令 -> 服务器执行并返回结果。

2. 核心技术解析

2.1 Socket通信
系统底层的网络通信基于Python内置的`socket`库实现。通过创建`AF_INET`类型的`SOCK_STREAM`套接字，建立与Minecraft服务器指定RCON端口的TCP连接，为上层数据的收发提供可靠的传输通道。

2.2 MCRcon协议
MCRcon是Minecraft官方提供的远程管理协议。所有在客户端和服务器之间传输的数据都必须封装成特定的数据包（Packet）格式。一个完整的MCRcon数据包由以下字段按顺序构成：

- Length: 32位小端序（Little-endian）整数，表示后续所有字段（Request ID, Type, Payload, Padding）的总字节长度。
- Request ID: 32位小端序整数，由客户端生成，用于唯一标识一次请求。服务器的响应将包含相同的ID，以便客户端匹配请求与响应。
- Type: 32位小端序整数，表示数据包的类型。关键类型值包括：3（用于登录认证请求）和2（用于执行命令请求）。
- Payload: ASCII编码的可变长度字符串，是数据包的核心载荷，其内容为RCON密码或具体的游戏指令。
- Padding: 两个空字节（0x00），作为数据包的结束标志。

程序的核心任务之一就是使用Python的`struct`库，对上述字段进行精确的二进制打包（pack）和解包（unpack），以确保与服务器的正确通信。

3. 模块设计

为提高代码的内聚性和可维护性，系统划分为以下几个主要模块：

- command.py (核心协议模块): 计划封装一个`MCRcon`类，用于处理底层的Socket连接、数据包的打包与解包、认证及命令收发等全部协议相关逻辑。这是整个系统的基础和核心。

- main_automation.py (主程序模块): 作为程序的用户交互入口，负责循环读取用户输入的指令，调用`MCRcon`实例与服务器交互，并对返回结果进行格式化输出。

- automation_win.py (自动化任务模块): 作为一个独立的示例脚本，用于演示如何调用`MCRcon`类来实现定时、批量的管理任务，例如定时向服务器发送全局公告。

- id.txt (配置文件): 以纯文本形式存储服务器的IP地址、RCON端口和密码。主程序启动时将从此文件读取配置，实现配置与代码的分离，便于用户修改。